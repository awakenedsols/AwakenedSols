{"ast":null,"code":"// import { useCallback, useEffect, useMemo, useState } from 'react';\n// import * as anchor from '@project-serum/anchor';\n// import { BrowserRouter, Route, Link } from \"react-router-dom\";\n// import styled from 'styled-components';\n// import { Container, Snackbar } from '@material-ui/core';\n// import Paper from '@material-ui/core/Paper';\n// import Alert from '@material-ui/lab/Alert';\n// import Grid from '@material-ui/core/Grid';\n// import Typography from '@material-ui/core/Typography';\n// import Typewriter from \"typewriter-effect\";\n// import {\n//   Commitment,\n//   Connection,\n//   PublicKey,\n//   Transaction,\n// } from '@solana/web3.js';\n// import { useWallet } from '@solana/wallet-adapter-react';\n// import { WalletDialogButton } from '@solana/wallet-adapter-material-ui';\n// import {\n//   awaitTransactionSignatureConfirmation,\n//   CANDY_MACHINE_PROGRAM,\n//   CandyMachineAccount,\n//   createAccountsForMint,\n//   getCandyMachineState,\n//   getCollectionPDA,\n//   mintOneToken,\n//   SetupState,\n// } from './candy-machine';\n// import { AlertState, formatNumber, getAtaForMint, toDate } from './utils';\n// import { MintButton } from './MintButton';\n// import { GatewayProvider } from '@civic/solana-gateway-react';\n// import { sendTransaction } from './connection';\n// import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\n// import './home.css';\n// const ConnectButton = styled(WalletDialogButton)`\n//   width: 100%;\n//   height: 60px;\n//   margin-top: 10px;\n//   margin-bottom: 5px;\n//   background: linear-gradient(180deg, #604ae5 0%, #813eee 100%);\n//   color: white;\n//   font-size: 16px;\n//   font-weight: bold;\n// `;\n// const MintContainer = styled.div``; // add your owns styles here\n// export interface HomeProps {\n//   candyMachineId?: anchor.web3.PublicKey;\n//   connection: anchor.web3.Connection;\n//   txTimeout: number;\n//   rpcHost: string;\n//   network: WalletAdapterNetwork;\n// }\n// const Home = (props: HomeProps) => {\n//   const [isUserMinting, setIsUserMinting] = useState(false);\n//   const [candyMachine, setCandyMachine] = useState<CandyMachineAccount>();\n//   const [alertState, setAlertState] = useState<AlertState>({\n//     open: false,\n//     message: '',\n//     severity: undefined,\n//   });\n//   const [isActive, setIsActive] = useState(false);\n//   const [endDate, setEndDate] = useState<Date>();\n//   const [itemsRemaining, setItemsRemaining] = useState<number>();\n//   const [isWhitelistUser, setIsWhitelistUser] = useState(false);\n//   const [isPresale, setIsPresale] = useState(false);\n//   const [isValidBalance, setIsValidBalance] = useState(false);\n//   const [discountPrice, setDiscountPrice] = useState<anchor.BN>();\n//   const [needTxnSplit, setNeedTxnSplit] = useState(true);\n//   const [setupTxn, setSetupTxn] = useState<SetupState>();\n//   const rpcUrl = props.rpcHost;\n//   const wallet = useWallet();\n//   const anchorWallet = useMemo(() => {\n//     if (\n//       !wallet ||\n//       !wallet.publicKey ||\n//       !wallet.signAllTransactions ||\n//       !wallet.signTransaction\n//     ) {\n//       return;\n//     }\n//     return {\n//       publicKey: wallet.publicKey,\n//       signAllTransactions: wallet.signAllTransactions,\n//       signTransaction: wallet.signTransaction,\n//     } as anchor.Wallet;\n//   }, [wallet]);\n//   const refreshCandyMachineState = useCallback(\n//     async (commitment: Commitment = 'confirmed') => {\n//       if (!anchorWallet) {\n//         return;\n//       }\n//       const connection = new Connection(props.rpcHost, commitment);\n//       if (props.candyMachineId) {\n//         console.log(props?.candyMachineId);\n//         try {\n//           const cndy = await getCandyMachineState(\n//             anchorWallet,\n//             props.candyMachineId,\n//             connection,\n//           );\n//           let active =\n//             cndy?.state.goLiveDate?.toNumber() < new Date().getTime() / 1000;\n//           let presale = false;\n//           // duplication of state to make sure we have the right values!\n//           let isWLUser = false;\n//           let userPrice = cndy.state.price;\n//           userPrice = isWLUser ? userPrice : cndy.state.price;\n//           if (cndy?.state.tokenMint) {\n//             // retrieves the SPL token\n//             const mint = new anchor.web3.PublicKey(cndy.state.tokenMint);\n//             const token = (\n//               await getAtaForMint(mint, anchorWallet.publicKey)\n//             )[0];\n//             try {\n//               const balance = await connection.getTokenAccountBalance(token);\n//               const valid = new anchor.BN(balance.value.amount).gte(userPrice);\n//               // only allow user to mint if token balance >  the user if the balance > 0\n//               setIsValidBalance(valid);\n//               active = active && valid;\n//             } catch (e) {\n//               setIsValidBalance(false);\n//               active = false;\n//               // no whitelist user, no mint\n//               console.log('There was a problem fetching SPL token balance');\n//               console.log(e);\n//             }\n//           } else {\n//             const balance = new anchor.BN(\n//               await connection.getBalance(anchorWallet.publicKey),\n//             );\n//             const valid = balance.gte(userPrice);\n//             setIsValidBalance(valid);\n//             active = active && valid;\n//           }\n//           if (cndy.state.isSoldOut) {\n//             active = false;\n//           }\n//           const [collectionPDA] = await getCollectionPDA(props.candyMachineId);\n//           const collectionPDAAccount = await connection.getAccountInfo(\n//             collectionPDA,\n//           );\n//           setIsActive((cndy.state.isActive = active));\n//           setIsPresale((cndy.state.isPresale = presale));\n//           setCandyMachine(cndy);\n//           const txnEstimate =\n//             892 +\n//             (!!collectionPDAAccount && cndy.state.retainAuthority ? 182 : 0) +\n//             (cndy.state.tokenMint ? 177 : 0) +\n//             (cndy.state.whitelistMintSettings ? 33 : 0) +\n//             (cndy.state.whitelistMintSettings?.mode?.burnEveryTime ? 145 : 0) +\n//             (cndy.state.gatekeeper ? 33 : 0) +\n//             (cndy.state.gatekeeper?.expireOnUse ? 66 : 0);\n//           setNeedTxnSplit(txnEstimate > 1230);\n//         } catch (e) {\n//           if (e instanceof Error) {\n//             if (\n//               e.message === `Account does not exist ${props.candyMachineId}`\n//             ) {\n//               setAlertState({\n//                 open: true,\n//                 message: `Couldn't fetch candy machine state from candy machine with address: ${props.candyMachineId}, using rpc: ${props.rpcHost}! You probably typed the REACT_APP_CANDY_MACHINE_ID value in wrong in your .env file, or you are using the wrong RPC!`,\n//                 severity: 'error',\n//                 hideDuration: null,\n//               });\n//             } else if (\n//               e.message.startsWith('failed to get info about account')\n//             ) {\n//               setAlertState({\n//                 open: true,\n//                 message: `Couldn't fetch candy machine state with rpc: ${props.rpcHost}! This probably means you have an issue with the REACT_APP_SOLANA_RPC_HOST value in your .env file, or you are not using a custom RPC!`,\n//                 severity: 'error',\n//                 hideDuration: null,\n//               });\n//             }\n//           } else {\n//             setAlertState({\n//               open: true,\n//               message: `${e}`,\n//               severity: 'error',\n//               hideDuration: null,\n//             });\n//           }\n//           console.log(e);\n//         }\n//       } else {\n//         setAlertState({\n//           open: true,\n//           message: `Your REACT_APP_CANDY_MACHINE_ID value in the .env file doesn't look right! Make sure you enter it in as plain base-58 address!`,\n//           severity: 'error',\n//           hideDuration: null,\n//         });\n//       }\n//     },\n//     [anchorWallet, props.candyMachineId, props.rpcHost],\n//   );\n//   const onMint = async (\n//     beforeTransactions: Transaction[] = [],\n//     afterTransactions: Transaction[] = [],\n//   ) => {\n//     try {\n//       setIsUserMinting(true);\n//       document.getElementById('#identity')?.click();\n//       if (wallet.connected && candyMachine?.program && wallet.publicKey) {\n//         let setupMint: SetupState | undefined;\n//         if (needTxnSplit && setupTxn === undefined) {\n//           setAlertState({\n//             open: true,\n//             message: 'Please sign account setup transaction',\n//             severity: 'info',\n//           });\n//           setupMint = await createAccountsForMint(\n//             candyMachine,\n//             wallet.publicKey,\n//           );\n//           let status: any = { err: true };\n//           if (setupMint.transaction) {\n//             status = await awaitTransactionSignatureConfirmation(\n//               setupMint.transaction,\n//               props.txTimeout,\n//               props.connection,\n//               true,\n//             );\n//           }\n//           if (status && !status.err) {\n//             setSetupTxn(setupMint);\n//             setAlertState({\n//               open: true,\n//               message:\n//                 'Setup transaction succeeded! Please sign minting transaction',\n//               severity: 'info',\n//             });\n//           } else {\n//             setAlertState({\n//               open: true,\n//               message: 'Mint failed! Please try again!',\n//               severity: 'error',\n//             });\n//             setIsUserMinting(false);\n//             return;\n//           }\n//         } else {\n//           setAlertState({\n//             open: true,\n//             message: 'Please sign minting transaction',\n//             severity: 'info',\n//           });\n//         }\n//         let mintResult = await mintOneToken(\n//           candyMachine,\n//           wallet.publicKey,\n//           beforeTransactions,\n//           afterTransactions,\n//           setupMint ?? setupTxn,\n//         );\n//         let status: any = { err: true };\n//         let metadataStatus = null;\n//         if (mintResult) {\n//           status = await awaitTransactionSignatureConfirmation(\n//             mintResult.mintTxId,\n//             props.txTimeout,\n//             props.connection,\n//             true,\n//           );\n//           metadataStatus =\n//             await candyMachine.program.provider.connection.getAccountInfo(\n//               mintResult.metadataKey,\n//               'processed',\n//             );\n//           console.log('Metadata status: ', !!metadataStatus);\n//         }\n//         if (status && !status.err && metadataStatus) {\n//           // manual update since the refresh might not detect\n//           // the change immediately\n//           console.log('status')\n//           let remaining = itemsRemaining! - 1;\n//           console.log(remaining);\n//           setItemsRemaining(remaining);\n//           setIsActive((candyMachine.state.isActive = remaining > 0));\n//           candyMachine.state.isSoldOut = remaining === 0;\n//           setSetupTxn(undefined);\n//           setAlertState({\n//             open: true,\n//             message: 'Congratulations! Mint succeeded!',\n//             severity: 'success',\n//             hideDuration: 7000,\n//           });\n//           refreshCandyMachineState('processed');\n//         } else if (status && !status.err) {\n//           setAlertState({\n//             open: true,\n//             message:\n//               'Mint likely failed! Anti-bot SOL 0.01 fee potentially charged! Check the explorer to confirm the mint failed and if so, make sure you are eligible to mint before trying again.',\n//             severity: 'error',\n//             hideDuration: 8000,\n//           });\n//           refreshCandyMachineState();\n//         } else {\n//           setAlertState({\n//             open: true,\n//             message: 'Mint failed! Please try again!',\n//             severity: 'error',\n//           });\n//           refreshCandyMachineState();\n//         }\n//       }\n//     } catch (error: any) {\n//       let message = error.msg || 'Minting failed! Please try again!';\n//       if (!error.msg) {\n//         if (!error.message) {\n//           message = 'Transaction timeout! Please try again.';\n//         } else if (error.message.indexOf('0x137')) {\n//           console.log(error);\n//           message = `SOLD OUT!`;\n//         } else if (error.message.indexOf('0x135')) {\n//           message = `Insufficient funds to mint. Please fund your wallet.`;\n//         }\n//       } else {\n//         if (error.code === 311) {\n//           console.log(error);\n//           message = `SOLD OUT!`;\n//           window.location.reload();\n//         } else if (error.code === 312) {\n//           message = `Minting period hasn't started yet.`;\n//         }\n//       }\n//       setAlertState({\n//         open: true,\n//         message,\n//         severity: 'error',\n//       });\n//       // updates the candy machine state to reflect the latest\n//       // information on chain\n//       refreshCandyMachineState();\n//     } finally {\n//       setIsUserMinting(false);\n//     }\n//   };\n//   useEffect(() => {\n//     refreshCandyMachineState();\n//     console.log('use efect');\n//     if(candyMachine) {\n//       console.log('candyMachine')\n//       console.log(candyMachine.state);\n//       setItemsRemaining(candyMachine.state.itemsRemaining);\n//       console.log(itemsRemaining);\n//   } \n//   }, [\n//     anchorWallet,\n//     props.candyMachineId,\n//     props.connection,\n//     refreshCandyMachineState,\n//   ]);\n//   useEffect(() => {\n//     (function loop() {\n//       setTimeout(() => {\n//         refreshCandyMachineState();\n//         loop();\n//       }, 20000);\n//     })();\n//   }, [refreshCandyMachineState]);\n//   return (\n//     <main>\n//       {/* {wallet && <p>Balance: {(balance || 0).toLocaleString()} SOL</p>} */}\n//       <div className=\"main\">\n//         <div id=\"mainEmptyDiv\"></div>\n//         <div className=\"mintContainer\">\n//         <Container>\n//         <Container maxWidth=\"xs\" style={{ position: 'relative' }}>\n//           <Paper\n//             style={{\n//               padding: 24,\n//               paddingBottom: 24,\n//               backgroundColor: '#151A1F',\n//               borderRadius: 6,\n//             }}\n//           >\n//             {!wallet.connected ? (\n//               <ConnectButton>Connect Wallet</ConnectButton>\n//             ) : (\n//               <>\n//                 {candyMachine && (\n//                   <Grid\n//                     container\n//                     direction=\"row\"\n//                     justifyContent=\"center\"\n//                     wrap=\"nowrap\"\n//                   >\n//                     <Grid item xs={3}>\n//                       <Typography variant=\"body2\" color=\"textSecondary\">\n//                         Remaining\n//                       </Typography>\n//                       <Typography\n//                         variant=\"h6\"\n//                         color=\"textPrimary\"\n//                         style={{\n//                           fontWeight: 'bold',\n//                         }}\n//                       >\n//                         {`${itemsRemaining}`}\n//                       </Typography>\n//                     </Grid>\n//                     <Grid item xs={4}>\n//                       <Typography variant=\"body2\" color=\"textSecondary\">\n//                         {isWhitelistUser && discountPrice\n//                           ? 'Discount Price'\n//                           : 'Price'}\n//                       </Typography>\n//                       <Typography\n//                         variant=\"h6\"\n//                         color=\"textPrimary\"\n//                         style={{ fontWeight: 'bold' }}\n//                       >\n//                         {isWhitelistUser && discountPrice\n//                           ? `◎ ${formatNumber.asNumber(discountPrice)}`\n//                           : `◎ ${formatNumber.asNumber(\n//                               candyMachine.state.price,\n//                             )}`}\n//                       </Typography>\n//                     </Grid>\n//                     <Grid item xs={5}>\n//                               <Typography\n//                                 variant=\"caption\"\n//                                 align=\"center\"\n//                                 display=\"block\"\n//                                 style={{ fontWeight: 'bold' }}\n//                               >\n//                                 MINT TBA\n//                               </Typography>\n//                     </Grid>\n//                   </Grid>\n//                 )}\n//                 <MintContainer>\n//                   {candyMachine?.state.isActive &&\n//                   candyMachine?.state.gatekeeper &&\n//                   wallet.publicKey &&\n//                   wallet.signTransaction ? (\n//                     <GatewayProvider\n//                       wallet={{\n//                         publicKey:\n//                           wallet.publicKey ||\n//                           new PublicKey(CANDY_MACHINE_PROGRAM),\n//                         //@ts-ignore\n//                         signTransaction: wallet.signTransaction,\n//                       }}\n//                       gatekeeperNetwork={\n//                         candyMachine?.state?.gatekeeper?.gatekeeperNetwork\n//                       }\n//                       clusterUrl={\n//                         props.network === WalletAdapterNetwork.Devnet\n//                           ? 'https://api.devnet.solana.com'\n//                           : rpcUrl\n//                       }\n//                       handleTransaction={async (transaction: Transaction) => {\n//                         setIsUserMinting(true);\n//                         const userMustSign = transaction.signatures.find(sig =>\n//                           sig.publicKey.equals(wallet.publicKey!),\n//                         );\n//                         if (userMustSign) {\n//                           setAlertState({\n//                             open: true,\n//                             message: 'Please sign one-time Civic Pass issuance',\n//                             severity: 'info',\n//                           });\n//                           try {\n//                             transaction = await wallet.signTransaction!(\n//                               transaction,\n//                             );\n//                           } catch (e) {\n//                             setAlertState({\n//                               open: true,\n//                               message: 'User cancelled signing',\n//                               severity: 'error',\n//                             });\n//                             // setTimeout(() => window.location.reload(), 2000);\n//                             setIsUserMinting(false);\n//                             throw e;\n//                           }\n//                         } else {\n//                           setAlertState({\n//                             open: true,\n//                             message: 'Refreshing Civic Pass',\n//                             severity: 'info',\n//                           });\n//                         }\n//                         try {\n//                           await sendTransaction(\n//                             props.connection,\n//                             wallet,\n//                             transaction,\n//                             [],\n//                             true,\n//                             'confirmed',\n//                           );\n//                           setAlertState({\n//                             open: true,\n//                             message: 'Please sign minting',\n//                             severity: 'info',\n//                           });\n//                         } catch (e) {\n//                           setAlertState({\n//                             open: true,\n//                             message:\n//                               'Solana dropped the transaction, please try again',\n//                             severity: 'warning',\n//                           });\n//                           console.error(e);\n//                           // setTimeout(() => window.location.reload(), 2000);\n//                           setIsUserMinting(false);\n//                           throw e;\n//                         }\n//                         await onMint();\n//                       }}\n//                       broadcastTransaction={false}\n//                       options={{ autoShowModal: false }}\n//                     >\n//                       <MintButton\n//                         candyMachine={candyMachine}\n//                         isMinting={isUserMinting}\n//                         setIsMinting={val => setIsUserMinting(val)}\n//                         onMint={onMint}\n//                         isActive={\n//                           isActive ||\n//                           (isPresale && isWhitelistUser && isValidBalance)\n//                         }\n//                       />\n//                     </GatewayProvider>\n//                   ) : (\n//                     <MintButton \n//                       candyMachine={candyMachine}\n//                       isMinting={isUserMinting}\n//                       setIsMinting={val => setIsUserMinting(val)}\n//                       onMint={onMint}\n//                       isActive={\n//                         isActive ||\n//                         (isPresale && isWhitelistUser && isValidBalance)\n//                       }\n//                     />\n//                   )}\n//                 </MintContainer>\n//               </>\n//             )}\n//           </Paper>\n//         </Container>\n//         <Snackbar\n//           open={alertState.open}\n//           autoHideDuration={\n//             alertState.hideDuration === undefined ? 6000 : alertState.hideDuration\n//           }\n//           onClose={() => setAlertState({ ...alertState, open: false })}\n//         >\n//           <Alert\n//             onClose={() => setAlertState({ ...alertState, open: false })}\n//             severity={alertState.severity}\n//           >\n//             {alertState.message}\n//           </Alert>\n//         </Snackbar>\n//       </Container>\n//           </div>\n//         </div>\n//         {<div id=\"about\"><div className=\"aboutContainer\">\n//           <h1 className=\"h1\">ABOUT</h1>\n//           <p>For those beginning or continuing their awakening on NFTs...\n//           </p><p>A collection of 2,222 uniquely generated Awakened Sols on the Solana blockchain.  \n//           </p><p>An alpha group and Sniping tool with unique features only available to holders.\n//           </p><p>An open minded community.\n//           </p><p>Mint Date: TBA</p>\n//           </div></div>}\n//           {<div id=\"roadmap\">\n//             <div className=\"roadMapContainer\">\n//           <h1 className=\"h1\">ROADMAP</h1>\n//           <ul><h3>Phase 1</h3>\n//             <li>Artwork Development</li>\n//             <li>Sniping Tool Development</li>\n//             <li>2,222 Awakened Sols Mint(0.5 SOL) - 50 OG(FREE) - 500 WL(0.3 SOL)</li>\n//             <li>Launch Sniping Tool to the public with special features for holders</li>\n//           </ul>\n//           <ul><h3>Phase 2</h3>\n//             <li>Listing on Secondary Market</li>\n//             <li>SOL Giveaways, NFT airdrops, WL spots</li>\n//             <li>Develop extra features based on feedback for Sniping Tool for NFT holders.</li>\n//           </ul>\n//           <ul><h3>Phase 3</h3>\n//             <li>Launch Sniping Tool v2</li>\n//           </ul>\n//           </div>\n//           </div>}\n//     </main>\n//   );\n// };\n// const getCountdownDate = (\n//   candyMachine: CandyMachineAccount,\n// ): Date | undefined => {\n//   if (\n//     candyMachine.state.isActive &&\n//     candyMachine.state.endSettings?.endSettingType.date\n//   ) {\n//     return toDate(candyMachine.state.endSettings.number);\n//   }\n//   return toDate(\n//     candyMachine.state.goLiveDate\n//       ? candyMachine.state.goLiveDate\n//       : candyMachine.state.isPresale\n//       ? new anchor.BN(new Date().getTime() / 1000)\n//       : undefined,\n//   );\n// };\n// export default Home;","map":{"version":3,"sources":["/Users/genesisbarrios/Documents/coding/web3/Awakened Sols/AwakenedSols/src/Home.tsx"],"names":[],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["// import { useCallback, useEffect, useMemo, useState } from 'react';\n// import * as anchor from '@project-serum/anchor';\n// import { BrowserRouter, Route, Link } from \"react-router-dom\";\n\n// import styled from 'styled-components';\n// import { Container, Snackbar } from '@material-ui/core';\n// import Paper from '@material-ui/core/Paper';\n// import Alert from '@material-ui/lab/Alert';\n// import Grid from '@material-ui/core/Grid';\n// import Typography from '@material-ui/core/Typography';\n// import Typewriter from \"typewriter-effect\";\n// import {\n//   Commitment,\n//   Connection,\n//   PublicKey,\n//   Transaction,\n// } from '@solana/web3.js';\n// import { useWallet } from '@solana/wallet-adapter-react';\n// import { WalletDialogButton } from '@solana/wallet-adapter-material-ui';\n// import {\n//   awaitTransactionSignatureConfirmation,\n//   CANDY_MACHINE_PROGRAM,\n//   CandyMachineAccount,\n//   createAccountsForMint,\n//   getCandyMachineState,\n//   getCollectionPDA,\n//   mintOneToken,\n//   SetupState,\n// } from './candy-machine';\n// import { AlertState, formatNumber, getAtaForMint, toDate } from './utils';\n// import { MintButton } from './MintButton';\n// import { GatewayProvider } from '@civic/solana-gateway-react';\n// import { sendTransaction } from './connection';\n// import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\n// import './home.css';\n\n// const ConnectButton = styled(WalletDialogButton)`\n//   width: 100%;\n//   height: 60px;\n//   margin-top: 10px;\n//   margin-bottom: 5px;\n//   background: linear-gradient(180deg, #604ae5 0%, #813eee 100%);\n//   color: white;\n//   font-size: 16px;\n//   font-weight: bold;\n// `;\n\n// const MintContainer = styled.div``; // add your owns styles here\n\n// export interface HomeProps {\n//   candyMachineId?: anchor.web3.PublicKey;\n//   connection: anchor.web3.Connection;\n//   txTimeout: number;\n//   rpcHost: string;\n//   network: WalletAdapterNetwork;\n// }\n\n// const Home = (props: HomeProps) => {\n//   const [isUserMinting, setIsUserMinting] = useState(false);\n//   const [candyMachine, setCandyMachine] = useState<CandyMachineAccount>();\n//   const [alertState, setAlertState] = useState<AlertState>({\n//     open: false,\n//     message: '',\n//     severity: undefined,\n//   });\n//   const [isActive, setIsActive] = useState(false);\n//   const [endDate, setEndDate] = useState<Date>();\n//   const [itemsRemaining, setItemsRemaining] = useState<number>();\n//   const [isWhitelistUser, setIsWhitelistUser] = useState(false);\n//   const [isPresale, setIsPresale] = useState(false);\n//   const [isValidBalance, setIsValidBalance] = useState(false);\n//   const [discountPrice, setDiscountPrice] = useState<anchor.BN>();\n//   const [needTxnSplit, setNeedTxnSplit] = useState(true);\n//   const [setupTxn, setSetupTxn] = useState<SetupState>();\n\n//   const rpcUrl = props.rpcHost;\n//   const wallet = useWallet();\n\n//   const anchorWallet = useMemo(() => {\n//     if (\n//       !wallet ||\n//       !wallet.publicKey ||\n//       !wallet.signAllTransactions ||\n//       !wallet.signTransaction\n//     ) {\n//       return;\n//     }\n\n//     return {\n//       publicKey: wallet.publicKey,\n//       signAllTransactions: wallet.signAllTransactions,\n//       signTransaction: wallet.signTransaction,\n//     } as anchor.Wallet;\n//   }, [wallet]);\n\n//   const refreshCandyMachineState = useCallback(\n//     async (commitment: Commitment = 'confirmed') => {\n//       if (!anchorWallet) {\n//         return;\n//       }\n\n//       const connection = new Connection(props.rpcHost, commitment);\n\n//       if (props.candyMachineId) {\n//         console.log(props?.candyMachineId);\n//         try {\n//           const cndy = await getCandyMachineState(\n//             anchorWallet,\n//             props.candyMachineId,\n//             connection,\n//           );\n//           let active =\n//             cndy?.state.goLiveDate?.toNumber() < new Date().getTime() / 1000;\n//           let presale = false;\n\n//           // duplication of state to make sure we have the right values!\n//           let isWLUser = false;\n//           let userPrice = cndy.state.price;\n\n//           userPrice = isWLUser ? userPrice : cndy.state.price;\n\n//           if (cndy?.state.tokenMint) {\n//             // retrieves the SPL token\n//             const mint = new anchor.web3.PublicKey(cndy.state.tokenMint);\n//             const token = (\n//               await getAtaForMint(mint, anchorWallet.publicKey)\n//             )[0];\n//             try {\n//               const balance = await connection.getTokenAccountBalance(token);\n\n//               const valid = new anchor.BN(balance.value.amount).gte(userPrice);\n\n//               // only allow user to mint if token balance >  the user if the balance > 0\n//               setIsValidBalance(valid);\n//               active = active && valid;\n//             } catch (e) {\n//               setIsValidBalance(false);\n//               active = false;\n//               // no whitelist user, no mint\n//               console.log('There was a problem fetching SPL token balance');\n//               console.log(e);\n//             }\n//           } else {\n//             const balance = new anchor.BN(\n//               await connection.getBalance(anchorWallet.publicKey),\n//             );\n//             const valid = balance.gte(userPrice);\n//             setIsValidBalance(valid);\n//             active = active && valid;\n//           }\n\n//           if (cndy.state.isSoldOut) {\n//             active = false;\n//           }\n\n//           const [collectionPDA] = await getCollectionPDA(props.candyMachineId);\n//           const collectionPDAAccount = await connection.getAccountInfo(\n//             collectionPDA,\n//           );\n\n//           setIsActive((cndy.state.isActive = active));\n//           setIsPresale((cndy.state.isPresale = presale));\n//           setCandyMachine(cndy);\n\n//           const txnEstimate =\n//             892 +\n//             (!!collectionPDAAccount && cndy.state.retainAuthority ? 182 : 0) +\n//             (cndy.state.tokenMint ? 177 : 0) +\n//             (cndy.state.whitelistMintSettings ? 33 : 0) +\n//             (cndy.state.whitelistMintSettings?.mode?.burnEveryTime ? 145 : 0) +\n//             (cndy.state.gatekeeper ? 33 : 0) +\n//             (cndy.state.gatekeeper?.expireOnUse ? 66 : 0);\n\n//           setNeedTxnSplit(txnEstimate > 1230);\n//         } catch (e) {\n//           if (e instanceof Error) {\n//             if (\n//               e.message === `Account does not exist ${props.candyMachineId}`\n//             ) {\n//               setAlertState({\n//                 open: true,\n//                 message: `Couldn't fetch candy machine state from candy machine with address: ${props.candyMachineId}, using rpc: ${props.rpcHost}! You probably typed the REACT_APP_CANDY_MACHINE_ID value in wrong in your .env file, or you are using the wrong RPC!`,\n//                 severity: 'error',\n//                 hideDuration: null,\n//               });\n//             } else if (\n//               e.message.startsWith('failed to get info about account')\n//             ) {\n//               setAlertState({\n//                 open: true,\n//                 message: `Couldn't fetch candy machine state with rpc: ${props.rpcHost}! This probably means you have an issue with the REACT_APP_SOLANA_RPC_HOST value in your .env file, or you are not using a custom RPC!`,\n//                 severity: 'error',\n//                 hideDuration: null,\n//               });\n//             }\n//           } else {\n//             setAlertState({\n//               open: true,\n//               message: `${e}`,\n//               severity: 'error',\n//               hideDuration: null,\n//             });\n//           }\n//           console.log(e);\n//         }\n//       } else {\n//         setAlertState({\n//           open: true,\n//           message: `Your REACT_APP_CANDY_MACHINE_ID value in the .env file doesn't look right! Make sure you enter it in as plain base-58 address!`,\n//           severity: 'error',\n//           hideDuration: null,\n//         });\n//       }\n//     },\n//     [anchorWallet, props.candyMachineId, props.rpcHost],\n//   );\n\n//   const onMint = async (\n//     beforeTransactions: Transaction[] = [],\n//     afterTransactions: Transaction[] = [],\n//   ) => {\n//     try {\n//       setIsUserMinting(true);\n//       document.getElementById('#identity')?.click();\n//       if (wallet.connected && candyMachine?.program && wallet.publicKey) {\n//         let setupMint: SetupState | undefined;\n//         if (needTxnSplit && setupTxn === undefined) {\n//           setAlertState({\n//             open: true,\n//             message: 'Please sign account setup transaction',\n//             severity: 'info',\n//           });\n//           setupMint = await createAccountsForMint(\n//             candyMachine,\n//             wallet.publicKey,\n//           );\n//           let status: any = { err: true };\n//           if (setupMint.transaction) {\n//             status = await awaitTransactionSignatureConfirmation(\n//               setupMint.transaction,\n//               props.txTimeout,\n//               props.connection,\n//               true,\n//             );\n//           }\n//           if (status && !status.err) {\n//             setSetupTxn(setupMint);\n//             setAlertState({\n//               open: true,\n//               message:\n//                 'Setup transaction succeeded! Please sign minting transaction',\n//               severity: 'info',\n//             });\n//           } else {\n//             setAlertState({\n//               open: true,\n//               message: 'Mint failed! Please try again!',\n//               severity: 'error',\n//             });\n//             setIsUserMinting(false);\n//             return;\n//           }\n//         } else {\n//           setAlertState({\n//             open: true,\n//             message: 'Please sign minting transaction',\n//             severity: 'info',\n//           });\n//         }\n\n//         let mintResult = await mintOneToken(\n//           candyMachine,\n//           wallet.publicKey,\n//           beforeTransactions,\n//           afterTransactions,\n//           setupMint ?? setupTxn,\n//         );\n\n//         let status: any = { err: true };\n//         let metadataStatus = null;\n//         if (mintResult) {\n//           status = await awaitTransactionSignatureConfirmation(\n//             mintResult.mintTxId,\n//             props.txTimeout,\n//             props.connection,\n//             true,\n//           );\n\n//           metadataStatus =\n//             await candyMachine.program.provider.connection.getAccountInfo(\n//               mintResult.metadataKey,\n//               'processed',\n//             );\n//           console.log('Metadata status: ', !!metadataStatus);\n//         }\n\n//         if (status && !status.err && metadataStatus) {\n//           // manual update since the refresh might not detect\n//           // the change immediately\n//           console.log('status')\n//           let remaining = itemsRemaining! - 1;\n//           console.log(remaining);\n//           setItemsRemaining(remaining);\n//           setIsActive((candyMachine.state.isActive = remaining > 0));\n//           candyMachine.state.isSoldOut = remaining === 0;\n//           setSetupTxn(undefined);\n//           setAlertState({\n//             open: true,\n//             message: 'Congratulations! Mint succeeded!',\n//             severity: 'success',\n//             hideDuration: 7000,\n//           });\n//           refreshCandyMachineState('processed');\n//         } else if (status && !status.err) {\n//           setAlertState({\n//             open: true,\n//             message:\n//               'Mint likely failed! Anti-bot SOL 0.01 fee potentially charged! Check the explorer to confirm the mint failed and if so, make sure you are eligible to mint before trying again.',\n//             severity: 'error',\n//             hideDuration: 8000,\n//           });\n//           refreshCandyMachineState();\n//         } else {\n//           setAlertState({\n//             open: true,\n//             message: 'Mint failed! Please try again!',\n//             severity: 'error',\n//           });\n//           refreshCandyMachineState();\n//         }\n//       }\n//     } catch (error: any) {\n//       let message = error.msg || 'Minting failed! Please try again!';\n//       if (!error.msg) {\n//         if (!error.message) {\n//           message = 'Transaction timeout! Please try again.';\n//         } else if (error.message.indexOf('0x137')) {\n//           console.log(error);\n//           message = `SOLD OUT!`;\n//         } else if (error.message.indexOf('0x135')) {\n//           message = `Insufficient funds to mint. Please fund your wallet.`;\n//         }\n//       } else {\n//         if (error.code === 311) {\n//           console.log(error);\n//           message = `SOLD OUT!`;\n//           window.location.reload();\n//         } else if (error.code === 312) {\n//           message = `Minting period hasn't started yet.`;\n//         }\n//       }\n\n//       setAlertState({\n//         open: true,\n//         message,\n//         severity: 'error',\n//       });\n//       // updates the candy machine state to reflect the latest\n//       // information on chain\n//       refreshCandyMachineState();\n//     } finally {\n//       setIsUserMinting(false);\n//     }\n//   };\n\n//   useEffect(() => {\n//     refreshCandyMachineState();\n//     console.log('use efect');\n//     if(candyMachine) {\n//       console.log('candyMachine')\n//       console.log(candyMachine.state);\n//       setItemsRemaining(candyMachine.state.itemsRemaining);\n//       console.log(itemsRemaining);\n//   } \n//   }, [\n//     anchorWallet,\n//     props.candyMachineId,\n//     props.connection,\n//     refreshCandyMachineState,\n//   ]);\n\n//   useEffect(() => {\n//     (function loop() {\n//       setTimeout(() => {\n//         refreshCandyMachineState();\n//         loop();\n//       }, 20000);\n//     })();\n//   }, [refreshCandyMachineState]);\n\n//   return (\n//     <main>\n      \n//       {/* {wallet && <p>Balance: {(balance || 0).toLocaleString()} SOL</p>} */}\n//       <div className=\"main\">\n//         <div id=\"mainEmptyDiv\"></div>\n//         <div className=\"mintContainer\">\n//         <Container>\n//         <Container maxWidth=\"xs\" style={{ position: 'relative' }}>\n//           <Paper\n//             style={{\n//               padding: 24,\n//               paddingBottom: 24,\n//               backgroundColor: '#151A1F',\n//               borderRadius: 6,\n//             }}\n//           >\n//             {!wallet.connected ? (\n//               <ConnectButton>Connect Wallet</ConnectButton>\n//             ) : (\n//               <>\n//                 {candyMachine && (\n//                   <Grid\n//                     container\n//                     direction=\"row\"\n//                     justifyContent=\"center\"\n//                     wrap=\"nowrap\"\n//                   >\n//                     <Grid item xs={3}>\n//                       <Typography variant=\"body2\" color=\"textSecondary\">\n//                         Remaining\n//                       </Typography>\n//                       <Typography\n//                         variant=\"h6\"\n//                         color=\"textPrimary\"\n//                         style={{\n//                           fontWeight: 'bold',\n//                         }}\n//                       >\n//                         {`${itemsRemaining}`}\n//                       </Typography>\n//                     </Grid>\n//                     <Grid item xs={4}>\n//                       <Typography variant=\"body2\" color=\"textSecondary\">\n//                         {isWhitelistUser && discountPrice\n//                           ? 'Discount Price'\n//                           : 'Price'}\n//                       </Typography>\n//                       <Typography\n//                         variant=\"h6\"\n//                         color=\"textPrimary\"\n//                         style={{ fontWeight: 'bold' }}\n//                       >\n//                         {isWhitelistUser && discountPrice\n//                           ? `◎ ${formatNumber.asNumber(discountPrice)}`\n//                           : `◎ ${formatNumber.asNumber(\n//                               candyMachine.state.price,\n//                             )}`}\n//                       </Typography>\n//                     </Grid>\n//                     <Grid item xs={5}>\n//                               <Typography\n//                                 variant=\"caption\"\n//                                 align=\"center\"\n//                                 display=\"block\"\n//                                 style={{ fontWeight: 'bold' }}\n//                               >\n//                                 MINT TBA\n//                               </Typography>\n//                     </Grid>\n//                   </Grid>\n//                 )}\n//                 <MintContainer>\n//                   {candyMachine?.state.isActive &&\n//                   candyMachine?.state.gatekeeper &&\n//                   wallet.publicKey &&\n//                   wallet.signTransaction ? (\n//                     <GatewayProvider\n//                       wallet={{\n//                         publicKey:\n//                           wallet.publicKey ||\n//                           new PublicKey(CANDY_MACHINE_PROGRAM),\n//                         //@ts-ignore\n//                         signTransaction: wallet.signTransaction,\n//                       }}\n//                       gatekeeperNetwork={\n//                         candyMachine?.state?.gatekeeper?.gatekeeperNetwork\n//                       }\n//                       clusterUrl={\n//                         props.network === WalletAdapterNetwork.Devnet\n//                           ? 'https://api.devnet.solana.com'\n//                           : rpcUrl\n//                       }\n//                       handleTransaction={async (transaction: Transaction) => {\n//                         setIsUserMinting(true);\n//                         const userMustSign = transaction.signatures.find(sig =>\n//                           sig.publicKey.equals(wallet.publicKey!),\n//                         );\n//                         if (userMustSign) {\n//                           setAlertState({\n//                             open: true,\n//                             message: 'Please sign one-time Civic Pass issuance',\n//                             severity: 'info',\n//                           });\n//                           try {\n//                             transaction = await wallet.signTransaction!(\n//                               transaction,\n//                             );\n//                           } catch (e) {\n//                             setAlertState({\n//                               open: true,\n//                               message: 'User cancelled signing',\n//                               severity: 'error',\n//                             });\n//                             // setTimeout(() => window.location.reload(), 2000);\n//                             setIsUserMinting(false);\n//                             throw e;\n//                           }\n//                         } else {\n//                           setAlertState({\n//                             open: true,\n//                             message: 'Refreshing Civic Pass',\n//                             severity: 'info',\n//                           });\n//                         }\n//                         try {\n//                           await sendTransaction(\n//                             props.connection,\n//                             wallet,\n//                             transaction,\n//                             [],\n//                             true,\n//                             'confirmed',\n//                           );\n//                           setAlertState({\n//                             open: true,\n//                             message: 'Please sign minting',\n//                             severity: 'info',\n//                           });\n//                         } catch (e) {\n//                           setAlertState({\n//                             open: true,\n//                             message:\n//                               'Solana dropped the transaction, please try again',\n//                             severity: 'warning',\n//                           });\n//                           console.error(e);\n//                           // setTimeout(() => window.location.reload(), 2000);\n//                           setIsUserMinting(false);\n//                           throw e;\n//                         }\n//                         await onMint();\n//                       }}\n//                       broadcastTransaction={false}\n//                       options={{ autoShowModal: false }}\n//                     >\n//                       <MintButton\n//                         candyMachine={candyMachine}\n//                         isMinting={isUserMinting}\n//                         setIsMinting={val => setIsUserMinting(val)}\n//                         onMint={onMint}\n//                         isActive={\n//                           isActive ||\n//                           (isPresale && isWhitelistUser && isValidBalance)\n//                         }\n//                       />\n//                     </GatewayProvider>\n//                   ) : (\n//                     <MintButton \n//                       candyMachine={candyMachine}\n//                       isMinting={isUserMinting}\n//                       setIsMinting={val => setIsUserMinting(val)}\n//                       onMint={onMint}\n//                       isActive={\n//                         isActive ||\n//                         (isPresale && isWhitelistUser && isValidBalance)\n//                       }\n//                     />\n//                   )}\n//                 </MintContainer>\n//               </>\n//             )}\n//           </Paper>\n//         </Container>\n\n//         <Snackbar\n//           open={alertState.open}\n//           autoHideDuration={\n//             alertState.hideDuration === undefined ? 6000 : alertState.hideDuration\n//           }\n//           onClose={() => setAlertState({ ...alertState, open: false })}\n//         >\n//           <Alert\n//             onClose={() => setAlertState({ ...alertState, open: false })}\n//             severity={alertState.severity}\n//           >\n//             {alertState.message}\n//           </Alert>\n//         </Snackbar>\n//       </Container>\n//           </div>\n\n//         </div>\n\n//         {<div id=\"about\"><div className=\"aboutContainer\">\n//           <h1 className=\"h1\">ABOUT</h1>\n//           <p>For those beginning or continuing their awakening on NFTs...\n//           </p><p>A collection of 2,222 uniquely generated Awakened Sols on the Solana blockchain.  \n//           </p><p>An alpha group and Sniping tool with unique features only available to holders.\n//           </p><p>An open minded community.\n//           </p><p>Mint Date: TBA</p>\n//           </div></div>}\n\n//           {<div id=\"roadmap\">\n//             <div className=\"roadMapContainer\">\n//           <h1 className=\"h1\">ROADMAP</h1>\n//           <ul><h3>Phase 1</h3>\n//             <li>Artwork Development</li>\n//             <li>Sniping Tool Development</li>\n//             <li>2,222 Awakened Sols Mint(0.5 SOL) - 50 OG(FREE) - 500 WL(0.3 SOL)</li>\n//             <li>Launch Sniping Tool to the public with special features for holders</li>\n//           </ul>\n//           <ul><h3>Phase 2</h3>\n//             <li>Listing on Secondary Market</li>\n//             <li>SOL Giveaways, NFT airdrops, WL spots</li>\n//             <li>Develop extra features based on feedback for Sniping Tool for NFT holders.</li>\n//           </ul>\n//           <ul><h3>Phase 3</h3>\n//             <li>Launch Sniping Tool v2</li>\n//           </ul>\n//           </div>\n//           </div>}\n\n//     </main>\n//   );\n// };\n\n// const getCountdownDate = (\n//   candyMachine: CandyMachineAccount,\n// ): Date | undefined => {\n//   if (\n//     candyMachine.state.isActive &&\n//     candyMachine.state.endSettings?.endSettingType.date\n//   ) {\n//     return toDate(candyMachine.state.endSettings.number);\n//   }\n\n//   return toDate(\n//     candyMachine.state.goLiveDate\n//       ? candyMachine.state.goLiveDate\n//       : candyMachine.state.isPresale\n//       ? new anchor.BN(new Date().getTime() / 1000)\n//       : undefined,\n//   );\n// };\n\n// export default Home;\n"]},"metadata":{},"sourceType":"module"}