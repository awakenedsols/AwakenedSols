{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nexport function validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return !!props.scale[axis];\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  if (validScale(name)) {\n    var methodName = toNewName(name); // @ts-expect-error scaleTime is not directly compatible with our D3Scale definition\n\n    return d3Scale[methodName]();\n  }\n\n  return d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return getScaleFromName(defaultScale);\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : getScaleFromName(scale);\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n} // Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\n\nvar DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n} // TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var scaleType = DUCK_TYPES.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}","map":{"version":3,"sources":["/Users/genesisbarrios/Documents/coding/web3/Awakened Sols/AwakenedSols/node_modules/victory-core/es/victory-util/scale.js"],"names":["_isPlainObject","_isFunction","_includes","Helpers","Collection","d3Scale","supportedScaleStrings","toNewName","scale","capitalize","s","toUpperCase","slice","concat","validScale","copy","domain","range","isScaleDefined","props","axis","x","y","getScaleTypeFromProps","undefined","getType","getScaleFromDomain","Array","isArray","containsDates","getScaleTypeFromData","data","accessor","createAccessor","axisData","map","datum","processedData","getScaleFromName","name","methodName","scaleLinear","getBaseScale","getScaleFromProps","defaultScale","getDefaultScale","getScaleType","DUCK_TYPES","method","scaleType","filter","type"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,sBAA3B;AACA,OAAOC,WAAP,MAAwB,mBAAxB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,OAAO,KAAKC,OAAZ,MAAyB,WAAzB;AACA,OAAO,KAAKC,UAAZ,MAA4B,cAA5B;AACA,OAAO,KAAKC,OAAZ,MAAyB,yBAAzB;AACA,IAAIC,qBAAqB,GAAG,CAAC,QAAD,EAAW,MAAX,EAAmB,KAAnB,EAA0B,MAA1B,CAA5B,C,CAEA;;AACA,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB;AACA,MAAIC,UAAU,GAAG,UAAUC,CAAV,EAAa;AAC5B,WAAOA,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAD,CAAKC,WAAL,KAAqBD,CAAC,CAACE,KAAF,CAAQ,CAAR,CAAjC;AACD,GAFD;;AAIA,SAAO,QAAQC,MAAR,CAAeJ,UAAU,CAACD,KAAD,CAAzB,CAAP;AACD;;AAED,OAAO,SAASM,UAAT,CAAoBN,KAApB,EAA2B;AAChC,MAAI,OAAOA,KAAP,KAAiB,UAArB,EAAiC;AAC/B,WAAOP,WAAW,CAACO,KAAK,CAACO,IAAP,CAAX,IAA2Bd,WAAW,CAACO,KAAK,CAACQ,MAAP,CAAtC,IAAwDf,WAAW,CAACO,KAAK,CAACS,KAAP,CAA1E;AACD,GAFD,MAEO,IAAI,OAAOT,KAAP,KAAiB,QAArB,EAA+B;AACpC,WAAON,SAAS,CAACI,qBAAD,EAAwBE,KAAxB,CAAhB;AACD;;AAED,SAAO,KAAP;AACD;;AAED,SAASU,cAAT,CAAwBC,KAAxB,EAA+BC,IAA/B,EAAqC;AACnC,MAAI,CAACD,KAAK,CAACX,KAAX,EAAkB;AAChB,WAAO,KAAP;AACD,GAFD,MAEO,IAAIW,KAAK,CAACX,KAAN,CAAYa,CAAZ,IAAiBF,KAAK,CAACX,KAAN,CAAYc,CAAjC,EAAoC;AACzC,WAAO,CAAC,CAACH,KAAK,CAACX,KAAN,CAAYY,IAAZ,CAAT;AACD;;AAED,SAAO,IAAP;AACD;;AAED,SAASG,qBAAT,CAA+BJ,KAA/B,EAAsCC,IAAtC,EAA4C;AAC1C,MAAI,CAACF,cAAc,CAACC,KAAD,EAAQC,IAAR,CAAnB,EAAkC;AAChC,WAAOI,SAAP;AACD;;AAED,MAAIhB,KAAK,GAAGW,KAAK,CAACX,KAAN,CAAYY,IAAZ,KAAqBD,KAAK,CAACX,KAAvC;AACA,SAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCiB,OAAO,CAACjB,KAAD,CAAlD;AACD;;AAED,SAASkB,kBAAT,CAA4BP,KAA5B,EAAmCC,IAAnC,EAAyC;AACvC,MAAIJ,MAAJ;;AAEA,MAAIG,KAAK,CAACH,MAAN,IAAgBG,KAAK,CAACH,MAAN,CAAaI,IAAb,CAApB,EAAwC;AACtCJ,IAAAA,MAAM,GAAGG,KAAK,CAACH,MAAN,CAAaI,IAAb,CAAT;AACD,GAFD,MAEO,IAAID,KAAK,CAACH,MAAN,IAAgBW,KAAK,CAACC,OAAN,CAAcT,KAAK,CAACH,MAApB,CAApB,EAAiD;AACtDA,IAAAA,MAAM,GAAGG,KAAK,CAACH,MAAf;AACD;;AAED,MAAI,CAACA,MAAL,EAAa;AACX,WAAOQ,SAAP;AACD;;AAED,SAAOpB,UAAU,CAACyB,aAAX,CAAyBb,MAAzB,IAAmC,MAAnC,GAA4C,QAAnD;AACD;;AAED,SAASc,oBAAT,CAA8BX,KAA9B,EAAqCC,IAArC,EAA2C;AACzC,MAAI,CAACD,KAAK,CAACY,IAAX,EAAiB;AACf,WAAO,QAAP;AACD;;AAED,MAAIC,QAAQ,GAAG7B,OAAO,CAAC8B,cAAR,CAAuBd,KAAK,CAACC,IAAD,CAA5B,CAAf;AACA,MAAIc,QAAQ,GAAGf,KAAK,CAACY,IAAN,CAAWI,GAAX,CAAe,UAAUC,KAAV,EAAiB;AAC7C,QAAIC,aAAa,GAAGrC,cAAc,CAACgC,QAAQ,CAACI,KAAD,CAAT,CAAd,GAAkCJ,QAAQ,CAACI,KAAD,CAAR,CAAgBhB,IAAhB,CAAlC,GAA0DY,QAAQ,CAACI,KAAD,CAAtF;AACA,WAAOC,aAAa,KAAKb,SAAlB,GAA8Ba,aAA9B,GAA8CD,KAAK,CAAChB,IAAD,CAA1D;AACD,GAHc,CAAf;AAIA,SAAOhB,UAAU,CAACyB,aAAX,CAAyBK,QAAzB,IAAqC,MAArC,GAA8C,QAArD;AACD,C,CAAC;;;AAGF,OAAO,SAASI,gBAAT,CAA0BC,IAA1B,EAAgC;AACrC,MAAIzB,UAAU,CAACyB,IAAD,CAAd,EAAsB;AACpB,QAAIC,UAAU,GAAGjC,SAAS,CAACgC,IAAD,CAA1B,CADoB,CACc;;AAElC,WAAOlC,OAAO,CAACmC,UAAD,CAAP,EAAP;AACD;;AAED,SAAOnC,OAAO,CAACoC,WAAR,EAAP;AACD;AACD,OAAO,SAASC,YAAT,CAAsBvB,KAAtB,EAA6BC,IAA7B,EAAmC;AACxC,MAAIZ,KAAK,GAAGmC,iBAAiB,CAACxB,KAAD,EAAQC,IAAR,CAA7B;;AAEA,MAAIZ,KAAJ,EAAW;AACT,WAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4B8B,gBAAgB,CAAC9B,KAAD,CAA5C,GAAsDA,KAA7D;AACD;;AAED,MAAIoC,YAAY,GAAGlB,kBAAkB,CAACP,KAAD,EAAQC,IAAR,CAAlB,IAAmCU,oBAAoB,CAACX,KAAD,EAAQC,IAAR,CAA1E;AACA,SAAOkB,gBAAgB,CAACM,YAAD,CAAvB;AACD;AACD,OAAO,SAASC,eAAT,GAA2B;AAChC,SAAOxC,OAAO,CAACoC,WAAR,EAAP;AACD;AACD,OAAO,SAASE,iBAAT,CAA2BxB,KAA3B,EAAkCC,IAAlC,EAAwC;AAC7C,MAAI,CAACF,cAAc,CAACC,KAAD,EAAQC,IAAR,CAAnB,EAAkC;AAChC,WAAOI,SAAP;AACD;;AAED,MAAIhB,KAAK,GAAGW,KAAK,CAACX,KAAN,CAAYY,IAAZ,KAAqBD,KAAK,CAACX,KAAvC;;AAEA,MAAIM,UAAU,CAACN,KAAD,CAAd,EAAuB;AACrB,WAAOP,WAAW,CAACO,KAAD,CAAX,GAAqBA,KAArB,GAA6B8B,gBAAgB,CAAC9B,KAAD,CAApD;AACD;;AAED,SAAOgB,SAAP;AACD;AACD,OAAO,SAASsB,YAAT,CAAsB3B,KAAtB,EAA6BC,IAA7B,EAAmC;AACxC;AACA,SAAOG,qBAAqB,CAACJ,KAAD,EAAQC,IAAR,CAArB,IAAsCU,oBAAoB,CAACX,KAAD,EAAQC,IAAR,CAAjE;AACD,C,CAAC;AACF;;AAEA,IAAI2B,UAAU,GAAG,CAAC;AAChBR,EAAAA,IAAI,EAAE,UADU;AAEhBS,EAAAA,MAAM,EAAE;AAFQ,CAAD,EAGd;AACDT,EAAAA,IAAI,EAAE,KADL;AAEDS,EAAAA,MAAM,EAAE;AAFP,CAHc,CAMf;AACF;AACA;AACA;AACA;AACA;AACA;AAZiB,CAAjB;AAcA,OAAO,SAASvB,OAAT,CAAiBjB,KAAjB,EAAwB;AAC7B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOA,KAAP;AACD;;AAED,MAAIyC,SAAS,GAAGF,UAAU,CAACG,MAAX,CAAkB,UAAUC,IAAV,EAAgB;AAChD,WAAO3C,KAAK,CAAC2C,IAAI,CAACH,MAAN,CAAL,KAAuBxB,SAA9B;AACD,GAFe,EAEb,CAFa,CAAhB;AAGA,SAAOyB,SAAS,GAAGA,SAAS,CAACV,IAAb,GAAoBf,SAApC;AACD","sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"];\n\n// Private Functions\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nexport function validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return !!props.scale[axis];\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  if (validScale(name)) {\n    var methodName = toNewName(name); // @ts-expect-error scaleTime is not directly compatible with our D3Scale definition\n\n    return d3Scale[methodName]();\n  }\n\n  return d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return getScaleFromName(defaultScale);\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : getScaleFromName(scale);\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n} // Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\n\nvar DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n} // TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var scaleType = DUCK_TYPES.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}"]},"metadata":{},"sourceType":"module"}