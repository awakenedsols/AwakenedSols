{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { IgrTimeAxisBreakCollection } from \"./igr-time-axis-break-collection\";\nimport { TimeAxisLabellingMode_$type } from \"./TimeAxisLabellingMode\";\nimport { IgrTimeAxisLabelFormatCollection } from \"./igr-time-axis-label-format-collection\";\nimport { IgrTimeAxisIntervalCollection } from \"./igr-time-axis-interval-collection\";\nimport { IgrTimeAxisBase } from \"./igr-time-axis-base\";\nimport { TimeXAxis } from \"./TimeXAxis\";\nimport { ensureEnum } from \"igniteui-react-core\";\nimport { TimeAxisBreakCollection as TimeAxisBreakCollection_internal } from \"./TimeAxisBreakCollection\";\nimport { TimeAxisBreak } from \"./TimeAxisBreak\";\nimport { SyncableObservableCollection$1 } from \"igniteui-react-core\";\nimport { TimeAxisLabelFormatCollection as TimeAxisLabelFormatCollection_internal } from \"./TimeAxisLabelFormatCollection\";\nimport { TimeAxisLabelFormat } from \"./TimeAxisLabelFormat\";\nimport { TimeAxisIntervalCollection as TimeAxisIntervalCollection_internal } from \"./TimeAxisIntervalCollection\";\nimport { TimeAxisInterval } from \"./TimeAxisInterval\";\n/**\n * A horizontal axis that uses a DateTime scale.\n*\n* The `IgrTimeXAxis` is a horizontal axis that uses a DateTime scale.\n*\n* ```ts\n*   <IgrDataChart\n*     dataSource={this.state.dataSource}\n*     width=\"700px\"\n*     height=\"500px\">\n*     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n* \t\t\tdateTimeMemberPath=\"Date\" />\n*  </IgrDataChart>\n* ```\n*\n* ```ts\n* this.timeXAxis = new IgrTimeXAxis({name: \"timeXAxis\"});\n* this.timeXAxis.title = \"Time X Axis\";\n* this.timeXAxis.dataSource = this.financialData;\n* this.timeXAxis.dateTimeMemberPath = \"Time\";\n* ```\n*/\n\nvar IgrTimeXAxis =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  __extends(IgrTimeXAxis, _super);\n\n  function IgrTimeXAxis(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._breaks = null;\n    _this._labelFormats = null;\n    _this._intervals = null;\n    return _this;\n  }\n\n  IgrTimeXAxis.prototype.createImplementation = function () {\n    return new TimeXAxis();\n  };\n\n  Object.defineProperty(IgrTimeXAxis.prototype, \"i\", {\n    /**\n                                 * @hidden\n                                 */\n    get: function () {\n      return this._implementation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"isPiecewise\", {\n    get: function () {\n      return this.i.ck;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"breaks\", {\n    /**\n     * TimeAxisBreaks to apply to this axis, representing spans of time to omit, such as weekends.\n    *\n    * The `breaks` to apply to this axis, representing spans of time to omit, such as weekends.\n    *\n    * ```ts\n    *   <IgrDataChart\n    *     dataSource={this.state.dataSource}\n    *     width=\"700px\"\n    *     height=\"500px\">\n    *     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n    * \t\t\tdateTimeMemberPath=\"Date\" >\n    *  </IgrTimeXAxis>\n    *  </IgrDataChart>\n    * ```\n    */\n    get: function () {\n      if (this._breaks === null) {\n        var coll = new IgrTimeAxisBreakCollection();\n        var innerColl = this.i.breaks;\n\n        if (!innerColl) {\n          innerColl = new TimeAxisBreakCollection_internal();\n        }\n\n        this._breaks = coll._fromInner(innerColl);\n      }\n\n      return this._breaks;\n    },\n    set: function (v) {\n      if (this._breaks !== null) {\n        this._breaks._setSyncTarget(null);\n\n        this._breaks = null;\n      }\n\n      var coll = new IgrTimeAxisBreakCollection();\n      this._breaks = coll._fromOuter(v);\n      var syncColl = new SyncableObservableCollection$1(TimeAxisBreak.$type);\n      var innerColl = this.i.breaks;\n\n      if (!innerColl) {\n        innerColl = new TimeAxisBreakCollection_internal();\n      }\n\n      syncColl._inner = innerColl;\n      syncColl.clear();\n\n      this._breaks._setSyncTarget(syncColl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"labellingMode\", {\n    /**\n     * Gets or sets the labelling mode to use when the automatic label formats are applied.\n    */\n    get: function () {\n      return this.i.nz;\n    },\n    set: function (v) {\n      this.i.nz = ensureEnum(TimeAxisLabellingMode_$type, v);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"labelFormats\", {\n    /**\n     * A list of axis label formats to apply, which are selected according to the visible axis range.\n     * The label format selected will be the one with the largest range smaller than the visible range of the axis.\n    */\n    get: function () {\n      if (this._labelFormats === null) {\n        var coll = new IgrTimeAxisLabelFormatCollection();\n        var innerColl = this.i.labelFormats;\n\n        if (!innerColl) {\n          innerColl = new TimeAxisLabelFormatCollection_internal();\n        }\n\n        this._labelFormats = coll._fromInner(innerColl);\n      }\n\n      return this._labelFormats;\n    },\n    set: function (v) {\n      if (this._labelFormats !== null) {\n        this._labelFormats._setSyncTarget(null);\n\n        this._labelFormats = null;\n      }\n\n      var coll = new IgrTimeAxisLabelFormatCollection();\n      this._labelFormats = coll._fromOuter(v);\n      var syncColl = new SyncableObservableCollection$1(TimeAxisLabelFormat.$type);\n      var innerColl = this.i.labelFormats;\n\n      if (!innerColl) {\n        innerColl = new TimeAxisLabelFormatCollection_internal();\n      }\n\n      syncColl._inner = innerColl;\n      syncColl.clear();\n\n      this._labelFormats._setSyncTarget(syncColl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"intervals\", {\n    /**\n     * A list of axis label intervals to apply, which are selected according to the visible axis range.\n     * The interval selected will be the one with the largest range smaller than the visible range of the axis.\n    */\n    get: function () {\n      if (this._intervals === null) {\n        var coll = new IgrTimeAxisIntervalCollection();\n        var innerColl = this.i.intervals;\n\n        if (!innerColl) {\n          innerColl = new TimeAxisIntervalCollection_internal();\n        }\n\n        this._intervals = coll._fromInner(innerColl);\n      }\n\n      return this._intervals;\n    },\n    set: function (v) {\n      if (this._intervals !== null) {\n        this._intervals._setSyncTarget(null);\n\n        this._intervals = null;\n      }\n\n      var coll = new IgrTimeAxisIntervalCollection();\n      this._intervals = coll._fromOuter(v);\n      var syncColl = new SyncableObservableCollection$1(TimeAxisInterval.$type);\n      var innerColl = this.i.intervals;\n\n      if (!innerColl) {\n        innerColl = new TimeAxisIntervalCollection_internal();\n      }\n\n      syncColl._inner = innerColl;\n      syncColl.clear();\n\n      this._intervals._setSyncTarget(syncColl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"isCategoryDateTime\", {\n    /**\n     * Gets if the current axis is of category date time axis type\n    */\n    get: function () {\n      return this.i.cb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  IgrTimeXAxis.prototype.findByName = function (name) {\n    var baseResult = _super.prototype.findByName.call(this, name);\n\n    if (baseResult) {\n      return baseResult;\n    }\n\n    if (this.breaks != null && this.breaks.findByName && this.breaks.findByName(name)) {\n      return this.breaks.findByName(name);\n    }\n\n    if (this.labelFormats != null && this.labelFormats.findByName && this.labelFormats.findByName(name)) {\n      return this.labelFormats.findByName(name);\n    }\n\n    if (this.intervals != null && this.intervals.findByName && this.intervals.findByName(name)) {\n      return this.intervals.findByName(name);\n    }\n\n    return null;\n  };\n\n  IgrTimeXAxis.prototype.getValueLabel = function (value) {\n    var iv = this.i.gc(value);\n    return iv;\n  };\n  /**\n   * Gets the index of the data item with the value nearest the given value.\n  \r\n  * @param unscaledValue  * The value to find a value close to.\n  */\n\n\n  IgrTimeXAxis.prototype.getIndexClosestToUnscaledValue = function (unscaledValue) {\n    var iv = this.i.i$f(unscaledValue);\n    return iv;\n  };\n\n  return IgrTimeXAxis;\n}(IgrTimeAxisBase);\n\nexport { IgrTimeXAxis };","map":{"version":3,"sources":["/Users/genesisbarrios/Documents/coding/web3/Awakened Sols/AwakenedSols/node_modules/igniteui-react-charts/esm5/lib/igr-time-x-axis.js"],"names":["__extends","IgrTimeAxisBreakCollection","TimeAxisLabellingMode_$type","IgrTimeAxisLabelFormatCollection","IgrTimeAxisIntervalCollection","IgrTimeAxisBase","TimeXAxis","ensureEnum","TimeAxisBreakCollection","TimeAxisBreakCollection_internal","TimeAxisBreak","SyncableObservableCollection$1","TimeAxisLabelFormatCollection","TimeAxisLabelFormatCollection_internal","TimeAxisLabelFormat","TimeAxisIntervalCollection","TimeAxisIntervalCollection_internal","TimeAxisInterval","IgrTimeXAxis","_super","props","_this","call","_breaks","_labelFormats","_intervals","prototype","createImplementation","Object","defineProperty","get","_implementation","enumerable","configurable","i","ck","coll","innerColl","breaks","_fromInner","set","v","_setSyncTarget","_fromOuter","syncColl","$type","_inner","clear","nz","labelFormats","intervals","cb","findByName","name","baseResult","getValueLabel","value","iv","gc","getIndexClosestToUnscaledValue","unscaledValue","i$f"],"mappings":"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","sourcesContent":["import { __extends } from \"tslib\";\nimport { IgrTimeAxisBreakCollection } from \"./igr-time-axis-break-collection\";\nimport { TimeAxisLabellingMode_$type } from \"./TimeAxisLabellingMode\";\nimport { IgrTimeAxisLabelFormatCollection } from \"./igr-time-axis-label-format-collection\";\nimport { IgrTimeAxisIntervalCollection } from \"./igr-time-axis-interval-collection\";\nimport { IgrTimeAxisBase } from \"./igr-time-axis-base\";\nimport { TimeXAxis } from \"./TimeXAxis\";\nimport { ensureEnum } from \"igniteui-react-core\";\nimport { TimeAxisBreakCollection as TimeAxisBreakCollection_internal } from \"./TimeAxisBreakCollection\";\nimport { TimeAxisBreak } from \"./TimeAxisBreak\";\nimport { SyncableObservableCollection$1 } from \"igniteui-react-core\";\nimport { TimeAxisLabelFormatCollection as TimeAxisLabelFormatCollection_internal } from \"./TimeAxisLabelFormatCollection\";\nimport { TimeAxisLabelFormat } from \"./TimeAxisLabelFormat\";\nimport { TimeAxisIntervalCollection as TimeAxisIntervalCollection_internal } from \"./TimeAxisIntervalCollection\";\nimport { TimeAxisInterval } from \"./TimeAxisInterval\";\n/**\n * A horizontal axis that uses a DateTime scale.\n*\n* The `IgrTimeXAxis` is a horizontal axis that uses a DateTime scale.\n*\n* ```ts\n*   <IgrDataChart\n*     dataSource={this.state.dataSource}\n*     width=\"700px\"\n*     height=\"500px\">\n*     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n* \t\t\tdateTimeMemberPath=\"Date\" />\n*  </IgrDataChart>\n* ```\n*\n* ```ts\n* this.timeXAxis = new IgrTimeXAxis({name: \"timeXAxis\"});\n* this.timeXAxis.title = \"Time X Axis\";\n* this.timeXAxis.dataSource = this.financialData;\n* this.timeXAxis.dateTimeMemberPath = \"Time\";\n* ```\n*/\nvar IgrTimeXAxis = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(IgrTimeXAxis, _super);\n    function IgrTimeXAxis(props) {\n        var _this = _super.call(this, props) || this;\n        _this._breaks = null;\n        _this._labelFormats = null;\n        _this._intervals = null;\n        return _this;\n    }\n    IgrTimeXAxis.prototype.createImplementation = function () {\n        return new TimeXAxis();\n    };\n    Object.defineProperty(IgrTimeXAxis.prototype, \"i\", {\n        /**\n                                     * @hidden\n                                     */\n        get: function () {\n            return this._implementation;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"isPiecewise\", {\n        get: function () {\n            return this.i.ck;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"breaks\", {\n        /**\n         * TimeAxisBreaks to apply to this axis, representing spans of time to omit, such as weekends.\n        *\n        * The `breaks` to apply to this axis, representing spans of time to omit, such as weekends.\n        *\n        * ```ts\n        *   <IgrDataChart\n        *     dataSource={this.state.dataSource}\n        *     width=\"700px\"\n        *     height=\"500px\">\n        *     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n        * \t\t\tdateTimeMemberPath=\"Date\" >\n        *  </IgrTimeXAxis>\n        *  </IgrDataChart>\n        * ```\n        */\n        get: function () {\n            if (this._breaks === null) {\n                var coll = new IgrTimeAxisBreakCollection();\n                var innerColl = this.i.breaks;\n                if (!innerColl) {\n                    innerColl = new TimeAxisBreakCollection_internal();\n                }\n                this._breaks = coll._fromInner(innerColl);\n            }\n            return this._breaks;\n        },\n        set: function (v) {\n            if (this._breaks !== null) {\n                this._breaks._setSyncTarget(null);\n                this._breaks = null;\n            }\n            var coll = new IgrTimeAxisBreakCollection();\n            this._breaks = coll._fromOuter(v);\n            var syncColl = new SyncableObservableCollection$1(TimeAxisBreak.$type);\n            var innerColl = this.i.breaks;\n            if (!innerColl) {\n                innerColl = new TimeAxisBreakCollection_internal();\n            }\n            syncColl._inner = innerColl;\n            syncColl.clear();\n            this._breaks._setSyncTarget(syncColl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"labellingMode\", {\n        /**\n         * Gets or sets the labelling mode to use when the automatic label formats are applied.\n        */\n        get: function () {\n            return this.i.nz;\n        },\n        set: function (v) {\n            this.i.nz = ensureEnum(TimeAxisLabellingMode_$type, v);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"labelFormats\", {\n        /**\n         * A list of axis label formats to apply, which are selected according to the visible axis range.\n         * The label format selected will be the one with the largest range smaller than the visible range of the axis.\n        */\n        get: function () {\n            if (this._labelFormats === null) {\n                var coll = new IgrTimeAxisLabelFormatCollection();\n                var innerColl = this.i.labelFormats;\n                if (!innerColl) {\n                    innerColl = new TimeAxisLabelFormatCollection_internal();\n                }\n                this._labelFormats = coll._fromInner(innerColl);\n            }\n            return this._labelFormats;\n        },\n        set: function (v) {\n            if (this._labelFormats !== null) {\n                this._labelFormats._setSyncTarget(null);\n                this._labelFormats = null;\n            }\n            var coll = new IgrTimeAxisLabelFormatCollection();\n            this._labelFormats = coll._fromOuter(v);\n            var syncColl = new SyncableObservableCollection$1(TimeAxisLabelFormat.$type);\n            var innerColl = this.i.labelFormats;\n            if (!innerColl) {\n                innerColl = new TimeAxisLabelFormatCollection_internal();\n            }\n            syncColl._inner = innerColl;\n            syncColl.clear();\n            this._labelFormats._setSyncTarget(syncColl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"intervals\", {\n        /**\n         * A list of axis label intervals to apply, which are selected according to the visible axis range.\n         * The interval selected will be the one with the largest range smaller than the visible range of the axis.\n        */\n        get: function () {\n            if (this._intervals === null) {\n                var coll = new IgrTimeAxisIntervalCollection();\n                var innerColl = this.i.intervals;\n                if (!innerColl) {\n                    innerColl = new TimeAxisIntervalCollection_internal();\n                }\n                this._intervals = coll._fromInner(innerColl);\n            }\n            return this._intervals;\n        },\n        set: function (v) {\n            if (this._intervals !== null) {\n                this._intervals._setSyncTarget(null);\n                this._intervals = null;\n            }\n            var coll = new IgrTimeAxisIntervalCollection();\n            this._intervals = coll._fromOuter(v);\n            var syncColl = new SyncableObservableCollection$1(TimeAxisInterval.$type);\n            var innerColl = this.i.intervals;\n            if (!innerColl) {\n                innerColl = new TimeAxisIntervalCollection_internal();\n            }\n            syncColl._inner = innerColl;\n            syncColl.clear();\n            this._intervals._setSyncTarget(syncColl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"isCategoryDateTime\", {\n        /**\n         * Gets if the current axis is of category date time axis type\n        */\n        get: function () {\n            return this.i.cb;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IgrTimeXAxis.prototype.findByName = function (name) {\n        var baseResult = _super.prototype.findByName.call(this, name);\n        if (baseResult) {\n            return baseResult;\n        }\n        if (this.breaks != null && this.breaks.findByName && this.breaks.findByName(name)) {\n            return this.breaks.findByName(name);\n        }\n        if (this.labelFormats != null && this.labelFormats.findByName && this.labelFormats.findByName(name)) {\n            return this.labelFormats.findByName(name);\n        }\n        if (this.intervals != null && this.intervals.findByName && this.intervals.findByName(name)) {\n            return this.intervals.findByName(name);\n        }\n        return null;\n    };\n    IgrTimeXAxis.prototype.getValueLabel = function (value) {\n        var iv = this.i.gc(value);\n        return (iv);\n    };\n    /**\n     * Gets the index of the data item with the value nearest the given value.\n    \r\n    * @param unscaledValue  * The value to find a value close to.\n    */\n    IgrTimeXAxis.prototype.getIndexClosestToUnscaledValue = function (unscaledValue) {\n        var iv = this.i.i$f(unscaledValue);\n        return (iv);\n    };\n    return IgrTimeXAxis;\n}(IgrTimeAxisBase));\nexport { IgrTimeXAxis };\n"]},"metadata":{},"sourceType":"module"}